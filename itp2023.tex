\documentclass{beamer}
\usetheme{default}
\usepackage{listings}
\lstset{mathescape, basicstyle=\ttfamily}

\title{Closure Properties of General Grammars Formally~Verified}
\author{Martin Dvorak, Jasmin Blanchette}
\date{2023-08-03}

\begin{document}
	
	\begin{frame}[plain]
		\maketitle
	\end{frame}
	
	\begin{frame}{Overview}
		\bigskip \bigskip
		\bigskip \bigskip
		\begin{itemize}
			\item Lean 3
			\item Mathlib as of 2022-03-15
			\item 12\,500 lines of code
			\item no dependent types for data
			\item no effort towards constructivism
		\end{itemize}
		\bigskip \bigskip
		\bigskip \bigskip
		\bigskip \bigskip
		
		https://github.com/madvorak/grammars/tree/publish
	\end{frame}
	
	\begin{frame}[fragile]{Symbols}
\begin{lstlisting}
inductive symbol (T : Type) (N : Type)
| terminal    : T $\rightarrow$ symbol
| nonterminal : N $\rightarrow$ symbol
\end{lstlisting}
		\bigskip
		\pause
		\begin{itemize}
			\item We don't explicitly state that \texttt{T} and \texttt{N} must be finite.
			\item Only a finite amount of symbols will appear in rewrite rules.
		\end{itemize}
	\end{frame}

	\begin{frame}[fragile]{\only<2->{Rules}}
\begin{lstlisting}
inductive symbol (T : Type) (N : Type)
| terminal    : T $\rightarrow$ symbol
| nonterminal : N $\rightarrow$ symbol
\end{lstlisting}
\pause
\begin{lstlisting}
structure grule (T : Type) (N : Type) :=
(input_L : list (symbol T N))
(input_N : N)
(input_R : list (symbol T N))
(output_string : list (symbol T N))
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Grammars}}
\begin{lstlisting}
structure grule (T : Type) (N : Type) :=
(input_L : list (symbol T N))
(input_N : N)
(input_R : list (symbol T N))
(output_string : list (symbol T N))
\end{lstlisting}
\pause
\begin{lstlisting}
structure grammar (T : Type) :=
(nt : Type)
(initial : nt)
(rules : list (grule T nt))
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Grammar transformations}}
\begin{lstlisting}
structure grammar (T : Type) :=
(nt : Type)
(initial : nt)
(rules : list (grule T nt))
\end{lstlisting}
\pause
\begin{lstlisting}
def grammar_transforms (g : grammar T)
  (w$_1$ w$_2$ : list (symbol T g.nt)) :
  Prop :=
$\exists$ r : grule T g.nt,
  r $\in$ g.rules                     $\wedge$
  $\exists$ u v : list (symbol T g.nt),
    w$_1\,$ = u ++ r.input_L ++
         [symbol.nonterminal r.input_N]
         ++ r.input_R ++ v               $\wedge$
    w$_2\,$ = u ++ r.output_string ++ v
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Grammar derivations}}
\begin{lstlisting}
def grammar_transforms (g : grammar T)
  (w$_1$ w$_2$ : list (symbol T g.nt)) :
  Prop :=
$\exists$ r : grule T g.nt,
  r $\in$ g.rules                     $\wedge$
  $\exists$ u v : list (symbol T g.nt),
    w$_1\,$ = u ++ r.input_L ++
         [symbol.nonterminal r.input_N]
         ++ r.input_R ++ v               $\wedge$
    w$_2\,$ = u ++ r.output_string ++ v
\end{lstlisting}
\pause
\begin{lstlisting}
def grammar_derives (g : grammar T) :
  list (symbol T g.nt) $\rightarrow$ list (symbol T g.nt)
  $\rightarrow$ Prop :=
relation.refl_trans_gen (grammar_transforms g)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Words generated by a grammar}}
\begin{lstlisting}
def grammar_derives (g : grammar T) :
  list (symbol T g.nt) $\rightarrow$ list (symbol T g.nt)
  $\rightarrow$ Prop :=
relation.refl_trans_gen (grammar_transforms g)
\end{lstlisting}
\pause
\begin{lstlisting}
def grammar_generates (g : grammar T)
  (w : list T) : Prop :=
grammar_derives g
  [symbol.nonterminal g.initial]
  (list.map symbol.terminal w)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Language of a grammar}}
\begin{lstlisting}
def grammar_generates (g : grammar T)
  (w : list T) : Prop :=
grammar_derives g
  [symbol.nonterminal g.initial]
  (list.map symbol.terminal w)

def language (T : Type) : Type :=
set (list T)
\end{lstlisting}
\pause
\begin{lstlisting}
def grammar_language (g : grammar T) :
  language T :=
set_of (grammar_generates g)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Type-0 languages}}
\begin{lstlisting}
def language (T : Type) : Type :=
set (list T)

def grammar_language (g : grammar T) :
  language T :=
set_of (grammar_generates g)
\end{lstlisting}
\pause
\begin{lstlisting}
def is_T0 (L : language T) : Prop :=
$\exists$ g : grammar T, grammar_language g = L
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{Union of languages}
\begin{lstlisting}
def set.union (s$_1$ s$_2$ : set T) : set T :=
{ a | a $\in$ s$_1$ $\vee$ a $\in$ s$_2$ }

instance : language.has_add (language T) :=
$\langle$set.union$\rangle$
\end{lstlisting}
\pause
\begin{lstlisting}
theorem T0_of_T0_u_T0 (L$_1$ L$_2$ : language T) :
  is_T0 L$_1$ $\wedge$ is_T0 L$_2\;\;\,\rightarrow\;\;\;$is_T0 (L$_1$ + L$_2$)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}{Proof of closure of type-0 language (under union)}
		\begin{itemize}
			\item given \texttt{g$_1$} and \texttt{g$_2$} $\;\rightsquigarrow\;$ construct \texttt{g}
			\pause
			\item prove, for any word,
			\begin{itemize}
				\item generated by \texttt{g$_1$} or \texttt{g$_2$} $\implies$ can be generated by \texttt{g}
				\pause
				\item generated by \texttt{g} $\implies$ can be generated by \texttt{g$_1$} or \texttt{g$_2$}
			\end{itemize}
		\end{itemize}
	\end{frame}
	
	\begin{frame}[fragile]{Reversal of a language}
\begin{lstlisting}
def reverse_lang (L : language T) :
  language T :=
$\lambda$ w : list T, w.reverse $\in$ L
\end{lstlisting}
\pause
\begin{lstlisting}
theorem T0_of_reverse_T0 (L : language T) :
is_T0 L$\;\;\,\rightarrow\;\;\,$is_T0 (reverse_lang L)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{Concatenation of languages}
\begin{lstlisting}
def set.image2 (f : $\alpha$ $\rightarrow$ $\beta$ $\rightarrow$ $\gamma$)
  (s : set $\alpha$) (t : set $\beta$) : set $\gamma$ :=
{ c | $\exists$ a b, a $\in$ s $\wedge$ b $\in$ t $\wedge$ f a b = c }

instance : language.has_mul (language T) :=
$\langle$set.image2 (++)$\rangle$
\end{lstlisting}
\pause
\begin{lstlisting}
theorem T0_of_T0_c_T0 (L$_1$ L$_2$ : language T) :
  is_T0 L$_1$ $\wedge$ is_T0 L$_2\;\;\,\rightarrow\;\;\;$is_T0 (L$_1$ * L$_2$)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{Kleene star of a language}
\begin{lstlisting}
def language.star (L : language T) :
  language T :=
{ x | $\exists$ S : list (list T), x = S.join
                    $\wedge$   $\forall$ y $\in$ S, y $\in$ L }
\end{lstlisting}
\pause
\begin{lstlisting}
theorem T0_of_star_T0 (L : language T) :
  is_T0 L$\;\;\,\rightarrow\;\;\,$is_T0 L.star
\end{lstlisting}
	\end{frame}
	
	\begin{frame}{Related work}{Chomsky hierarchy's lower levels}
		\begin{itemize}
			\item Finite automata and regular expressions
			\begin{itemize}
				\item in many languages
			\end{itemize}
			\item Context-free grammars
			\begin{itemize}
				\item (1992) Carlson et al.\ [Mizar]
				\item (2007) Minamide [Isabelle]
				\item (2010) Barthwal and Norrish [HOL4]
				\item (2015) Firsov and Uustalu [Agda]
				\item (2019) Ramos [Coq]
			\end{itemize}
		\end{itemize}
	\end{frame}
	
	\begin{frame}{Related work}{Turing-complete models}
	\begin{itemize}
		\item Turing machines
		\begin{itemize}
			\item (2001) Chen and Nakamura [Mizar]
			\item (2012) Asperti and Ricciotti [Matita]
			\item (2013) Xu et al.\ [Isabelle]
			\item (2019) Carneiro [Lean]
			\item (2020) Forster et al.\ [Coq]
			\item (2023) Balbach [Isabelle]
		\end{itemize}
		\item Random access machines
		\begin{itemize}
			\item (2003) Coen [Coq]
		\end{itemize}
		\item Lambda calculus
		\begin{itemize}
			\item (2017--2021) Forster, Kunze, and their colleagues [Coq]
		\end{itemize}
		\item Partial recursive functions
		\begin{itemize}
			\item (2011) Norrish [HOL4]
			\item (2019) Carneiro [Lean]
		\end{itemize}
	\end{itemize}
	\end{frame}
	
	\begin{frame}{Future work}
		
		Chomsky hierarchy
		\begin{itemize}
			\item Mathlib has regular languages.
			\item We have context-free languages.
			\item We want context-sensitive languages.
		\end{itemize} \smallskip
		
		Equivalence (computability theory) between TMs and grammars
		\begin{itemize}
			\item Turing machine $\;\rightsquigarrow\;$ General grammar
			\item General grammar $\;\rightsquigarrow\;$ Kuroda-NF grammar $\;\rightsquigarrow\;$ Nondeterministic multi-stack machine $\;\rightsquigarrow\;$ Turing machine
		\end{itemize}
		
	\end{frame}
	
\end{document}
