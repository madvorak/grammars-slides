\documentclass{beamer}
\usetheme{default}
\usepackage{listings}
\lstset{mathescape, basicstyle=\ttfamily}

\title{Closure Properties of General Grammars Formally~Verified}
\author{Martin Dvorak, Jasmin Blanchette}
\date{2023-08-03}

\begin{document}
	
	\begin{frame}[plain]
		\maketitle
	\end{frame}
	
	\begin{frame}[fragile]{Symbols}
\begin{lstlisting}
inductive symbol (T : Type) (N : Type)
| terminal    : T $\rightarrow$ symbol
| nonterminal : N $\rightarrow$ symbol
\end{lstlisting}
	\end{frame}

	\begin{frame}[fragile]{\only<2->{Rules}}
\begin{lstlisting}
inductive symbol (T : Type) (N : Type)
| terminal    : T $\rightarrow$ symbol
| nonterminal : N $\rightarrow$ symbol
\end{lstlisting}
\pause
\begin{lstlisting}
structure grule (T : Type) (N : Type) :=
(input_L : list (symbol T N))
(input_N : N)
(input_R : list (symbol T N))
(output_string : list (symbol T N))
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Grammars}}
\begin{lstlisting}
structure grule (T : Type) (N : Type) :=
(input_L : list (symbol T N))
(input_N : N)
(input_R : list (symbol T N))
(output_string : list (symbol T N))
\end{lstlisting}
\pause
\begin{lstlisting}
structure grammar (T : Type) :=
(nt : Type)
(initial : nt)
(rules : list (grule T nt))
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Grammar transformations}}
\begin{lstlisting}
structure grammar (T : Type) :=
(nt : Type)
(initial : nt)
(rules : list (grule T nt))
\end{lstlisting}
\pause
\begin{lstlisting}
def grammar_transforms (g : grammar T)
  (w$_1$ w$_2$ : list (symbol T g.nt)) :
  Prop :=
$\exists$ r : grule T g.nt,
  r $\in$ g.rules                     $\wedge$
  $\exists$ u v : list (symbol T g.nt),
    w$_1$ = u ++ r.input_L
         ++ [symbol.nonterminal r.input_N]
         ++ r.input_R ++ v                 $\wedge$
    w$_2$ = u ++ r.output_string ++ v
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Grammar derivations}}
\begin{lstlisting}
def grammar_transforms (g : grammar T)
  (w$_1$ w$_2$ : list (symbol T g.nt)) :
  Prop :=
$\exists$ r : grule T g.nt,
  r $\in$ g.rules                     $\wedge$
  $\exists$ u v : list (symbol T g.nt),
    w$_1$ = u ++ r.input_L
         ++ [symbol.nonterminal r.input_N]
         ++ r.input_R ++ v                 $\wedge$
    w$_2$ = u ++ r.output_string ++ v
\end{lstlisting}
\pause
\begin{lstlisting}
def grammar_derives (g : grammar T) :
  list (symbol T g.nt) $\rightarrow$ list (symbol T g.nt)
  $\rightarrow$ Prop :=
relation.refl_trans_gen (grammar_transforms g)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Words generated by a grammar}}
\begin{lstlisting}
def grammar_derives (g : grammar T) :
  list (symbol T g.nt) $\rightarrow$ list (symbol T g.nt)
  $\rightarrow$ Prop :=
relation.refl_trans_gen (grammar_transforms g)
\end{lstlisting}
\pause
\begin{lstlisting}
def grammar_generates (g : grammar T)
  (w : list T) : Prop :=
grammar_derives g
  [symbol.nonterminal g.initial]
  (list.map symbol.terminal w)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Language of a grammar}}
\begin{lstlisting}
def grammar_generates (g : grammar T)
  (w : list T) : Prop :=
grammar_derives g
  [symbol.nonterminal g.initial]
  (list.map symbol.terminal w)

def language (T : Type) : Type :=
set (list T)
\end{lstlisting}
\pause
\begin{lstlisting}
def grammar_language (g : grammar T) :
  language T :=
set_of (grammar_generates g)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Type-0 languages}}
\begin{lstlisting}
def language (T : Type) : Type :=
set (list T)

def grammar_language (g : grammar T) :
  language T :=
set_of (grammar_generates g)
\end{lstlisting}
\pause
\begin{lstlisting}
def is_T0 (L : language T) : Prop :=
$\exists$ g : grammar T, grammar_language g = L
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{Union of languages}
\begin{lstlisting}
def set.union (s$_1$ s$_2$ : set T) : set T :=
{a | a $\in$ s$_1$ $\vee$ a $\in$ s$_2$}

instance : language.has_add (language T) :=
$\langle$set.union$\rangle$
\end{lstlisting}
\pause
\begin{lstlisting}
theorem T0_of_T0_u_T0 (L$_1$ L$_2$ : language T) :
  is_T0 L$_1$ $\wedge$ is_T0 L$_2\;\;\,\rightarrow\;\;\;$is_T0 (L$_1$ + L$_2$)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{Reversal of a language}
\begin{lstlisting}
def reverse_lang (L : language T) :
  language T :=
$\lambda$ w : list T, w.reverse $\in$ L
\end{lstlisting}
\pause
\begin{lstlisting}
theorem T0_of_reverse_T0 (L : language T) :
is_T0 L$\;\;\,\rightarrow\;\;\,$is_T0 (reverse_lang L)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{Concatenation of languages}
\begin{lstlisting}
def set.image2 (f : $\alpha$ $\rightarrow$ $\beta$ $\rightarrow$ $\gamma$)
  (s : set $\alpha$) (t : set $\beta$) : set $\gamma$ :=
{c | $\exists$ a b, a $\in$ s $\wedge$ b $\in$ t $\wedge$ f a b = c}

instance : language.has_mul (language T) :=
$\langle$set.image2 (++)$\rangle$
\end{lstlisting}
\pause
\begin{lstlisting}
theorem T0_of_T0_c_T0 (L$_1$ L$_2$ : language T) :
  is_T0 L$_1$ $\wedge$ is_T0 L$_2\;\;\,\rightarrow\;\;\;$is_T0 (L$_1$ * L$_2$)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{Kleene star of a language}
\begin{lstlisting}
def language.star (L : language T) :
  language T :=
{x | $\exists$ S : list (list T), x = S.join    $\wedge$
                       $\forall$ y $\in$ S, y $\in$ L}
\end{lstlisting}
\pause
\begin{lstlisting}
theorem T0_of_star_T0 (L : language T) :
  is_T0 L$\;\;\,\rightarrow\;\;\,$is_T0 L.star
\end{lstlisting}
	\end{frame}
	
\end{document}
