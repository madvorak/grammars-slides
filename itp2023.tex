\documentclass{beamer}
\usetheme{default}
\usepackage{listings}
\lstset{mathescape, basicstyle=\ttfamily}

\title{Closure Properties of General Grammars Formally~Verified}
\author{Martin Dvorak, Jasmin Blanchette}
\date{2023-08-03}

\begin{document}
	
	\begin{frame}[plain]
		\maketitle
	\end{frame}
	
	\begin{frame}{Closure Properties of General Grammars\\Formally Verified}
		\begin{itemize}
			\item Lean 3
			\item Mathlib as of 2022-03-15
			\item 12\,500 lines of code
			\item no dependent types for data
			\item no effort towards constructivism
		\end{itemize}
	\end{frame}
	
	\begin{frame}[fragile]{Symbols}
\begin{lstlisting}
inductive symbol (T : Type) (N : Type)
| terminal    : T $\rightarrow$ symbol
| nonterminal : N $\rightarrow$ symbol
\end{lstlisting}
		\bigskip
		\pause
		\begin{itemize}
			\item We don't explicitly state that \texttt{T} and \texttt{N} must be finite.
			\item Only a finite amount of symbols will appear in rewrite rules.
		\end{itemize}
	\end{frame}

	\begin{frame}[fragile]{\only<2->{Rules}}
\begin{lstlisting}
inductive symbol (T : Type) (N : Type)
| terminal    : T $\rightarrow$ symbol
| nonterminal : N $\rightarrow$ symbol
\end{lstlisting}
\pause
\begin{lstlisting}
structure grule (T : Type) (N : Type) :=
(input_L : list (symbol T N))
(input_N : N)
(input_R : list (symbol T N))
(output_string : list (symbol T N))
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Grammars}}
\begin{lstlisting}
structure grule (T : Type) (N : Type) :=
(input_L : list (symbol T N))
(input_N : N)
(input_R : list (symbol T N))
(output_string : list (symbol T N))
\end{lstlisting}
\pause
\begin{lstlisting}
structure grammar (T : Type) :=
(nt : Type)
(initial : nt)
(rules : list (grule T nt))
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Grammar transformations}}
\begin{lstlisting}
structure grammar (T : Type) :=
(nt : Type)
(initial : nt)
(rules : list (grule T nt))
\end{lstlisting}
\pause
\begin{lstlisting}
def grammar_transforms (g : grammar T)
  (w$_1$ w$_2$ : list (symbol T g.nt)) :
  Prop :=
$\exists$ r : grule T g.nt,
  r $\in$ g.rules                     $\wedge$
  $\exists$ u v : list (symbol T g.nt),
    w$_1$ = u ++ r.input_L
         ++ [symbol.nonterminal r.input_N]
         ++ r.input_R ++ v                 $\wedge$
    w$_2$ = u ++ r.output_string ++ v
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Grammar derivations}}
\begin{lstlisting}
def grammar_transforms (g : grammar T)
  (w$_1$ w$_2$ : list (symbol T g.nt)) :
  Prop :=
$\exists$ r : grule T g.nt,
  r $\in$ g.rules                     $\wedge$
  $\exists$ u v : list (symbol T g.nt),
    w$_1$ = u ++ r.input_L
         ++ [symbol.nonterminal r.input_N]
         ++ r.input_R ++ v                 $\wedge$
    w$_2$ = u ++ r.output_string ++ v
\end{lstlisting}
\pause
\begin{lstlisting}
def grammar_derives (g : grammar T) :
  list (symbol T g.nt) $\rightarrow$ list (symbol T g.nt)
  $\rightarrow$ Prop :=
relation.refl_trans_gen (grammar_transforms g)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Words generated by a grammar}}
\begin{lstlisting}
def grammar_derives (g : grammar T) :
  list (symbol T g.nt) $\rightarrow$ list (symbol T g.nt)
  $\rightarrow$ Prop :=
relation.refl_trans_gen (grammar_transforms g)
\end{lstlisting}
\pause
\begin{lstlisting}
def grammar_generates (g : grammar T)
  (w : list T) : Prop :=
grammar_derives g
  [symbol.nonterminal g.initial]
  (list.map symbol.terminal w)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Language of a grammar}}
\begin{lstlisting}
def grammar_generates (g : grammar T)
  (w : list T) : Prop :=
grammar_derives g
  [symbol.nonterminal g.initial]
  (list.map symbol.terminal w)

def language (T : Type) : Type :=
set (list T)
\end{lstlisting}
\pause
\begin{lstlisting}
def grammar_language (g : grammar T) :
  language T :=
set_of (grammar_generates g)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{\only<2->{Type-0 languages}}
\begin{lstlisting}
def language (T : Type) : Type :=
set (list T)

def grammar_language (g : grammar T) :
  language T :=
set_of (grammar_generates g)
\end{lstlisting}
\pause
\begin{lstlisting}
def is_T0 (L : language T) : Prop :=
$\exists$ g : grammar T, grammar_language g = L
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{Union of languages}
\begin{lstlisting}
def set.union (s$_1$ s$_2$ : set T) : set T :=
{a | a $\in$ s$_1$ $\vee$ a $\in$ s$_2$}

instance : language.has_add (language T) :=
$\langle$set.union$\rangle$
\end{lstlisting}
\pause
\begin{lstlisting}
theorem T0_of_T0_u_T0 (L$_1$ L$_2$ : language T) :
  is_T0 L$_1$ $\wedge$ is_T0 L$_2\;\;\,\rightarrow\;\;\;$is_T0 (L$_1$ + L$_2$)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}{Proof of closure of type-0 language (under union)}
		\begin{itemize}
			\item given \texttt{g$_1$} and \texttt{g$_2$} $\;\rightsquigarrow\;$ construct \texttt{g}
			\pause
			\item prove, for any word,
			\begin{itemize}
				\item generated by \texttt{g$_1$} or \texttt{g$_2$} $\implies$ can be generated by \texttt{g}
				\pause
				\item generated by \texttt{g} $\implies$ can be generated by \texttt{g$_1$} or \texttt{g$_2$}
			\end{itemize}
		\end{itemize}
	\end{frame}
	
	\begin{frame}[fragile]{Reversal of a language}
\begin{lstlisting}
def reverse_lang (L : language T) :
  language T :=
$\lambda$ w : list T, w.reverse $\in$ L
\end{lstlisting}
\pause
\begin{lstlisting}
theorem T0_of_reverse_T0 (L : language T) :
is_T0 L$\;\;\,\rightarrow\;\;\,$is_T0 (reverse_lang L)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{Concatenation of languages}
\begin{lstlisting}
def set.image2 (f : $\alpha$ $\rightarrow$ $\beta$ $\rightarrow$ $\gamma$)
  (s : set $\alpha$) (t : set $\beta$) : set $\gamma$ :=
{c | $\exists$ a b, a $\in$ s $\wedge$ b $\in$ t $\wedge$ f a b = c}

instance : language.has_mul (language T) :=
$\langle$set.image2 (++)$\rangle$
\end{lstlisting}
\pause
\begin{lstlisting}
theorem T0_of_T0_c_T0 (L$_1$ L$_2$ : language T) :
  is_T0 L$_1$ $\wedge$ is_T0 L$_2\;\;\,\rightarrow\;\;\;$is_T0 (L$_1$ * L$_2$)
\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]{Kleene star of a language}
\begin{lstlisting}
def language.star (L : language T) :
  language T :=
{x | $\exists$ S : list (list T), x = S.join    $\wedge$
                       $\forall$ y $\in$ S, y $\in$ L}
\end{lstlisting}
\pause
\begin{lstlisting}
theorem T0_of_star_T0 (L : language T) :
  is_T0 L$\;\;\,\rightarrow\;\;\,$is_T0 L.star
\end{lstlisting}
	\end{frame}
	
	\begin{frame}{Related work --- Chomsky hierarchy's lower levels}
		\begin{itemize}
			\item Finite automata and regular expressions (in many languages)
			\item Context-free grammars
			\begin{itemize}
				\item (1992) Carlson et al.\ (Mizar)
				\item (2007) Minamide (Isabelle)
				\item (2010) Barthwal and Norrish (HOL4)
				\item (2015) Firsov and Uustalu (Agda)
				\item (2019) Ramos (Coq)
			\end{itemize}
		\end{itemize}
	\end{frame}
	
	\begin{frame}{Related work --- Turing-complete models}
	\begin{itemize}
		\item Turing machines
		\begin{itemize}
			\item (2001) Chen and Nakamura (Mizar)
			\item (2012) Asperti and Ricciotti (Matita)
			\item (2013) Xu et al.\ (Isabelle)
			\item (2019) Carneiro (Lean)
			\item (2020) Forster et al.\ (Coq)
			\item (2023) Balbach (Isabelle)
		\end{itemize}
		\item Random access machines
		\begin{itemize}
			\item (2003) Coen (Coq)
		\end{itemize}
		\item Lambda calculus
		\begin{itemize}
			\item (2017--2021) Forster, Kunze, and their colleagues (Coq)
		\end{itemize}
		\item Partial recursive functions
		\begin{itemize}
			\item (2011) Norrish (HOL4)
			\item (2019) Carneiro (Lean)
		\end{itemize}
	\end{itemize}
	\end{frame}
	
	\begin{frame}{Future work}
		Equivalence
	\end{frame}
	
\end{document}
